import { useChat } from "./useChat";
import { act, renderHook } from "@testing-library/react-hooks";
import { waitFor } from "@testing-library/react";
import * as sendSearchRequestInterface from "./utils/sendSearchRequest";
import * as streamQueryInterface from "@vectara/stream-query-client";
import { AgenticResponse, ChatTurn } from "./types";

jest.mock("@vectara/stream-query-client", () => {
  return {
    __esModule: true,
    ...jest.requireActual("@vectara/stream-query-client")
  };
});

const MOCK_API_RESPONSE = {
  chat_id: "mock-conversation-id",
  answer: "mock-answer",
  turn_id: "mock-turn-id",
  search_results: [
    {
      score: 0.8,
      text: "mock-text",
      document_id: "mock-doc-id",
      document_metadata: [{ name: "mock-name", value: "mock-value" }],
      part_metadata: []
    }
  ]
};

const AGENTIC_RESPONSE_MESSAGE_WITH_CONTENT_OVERRIDE = {
  content: "This is the message the chatbot will send when receiving a known agentic service event."
};

const AGENTIC_RESPONSE_MESSAGE_TO_APPEND_TO_QUERY_REPONSE = {
  post: "This is supplementary text to append to the original message generated by the query API."
};

describe("useChat", () => {
  let sendSearchRequestSpy: jest.SpyInstance;
  let streamQuerySpy: jest.SpyInstance;

  beforeEach(() => {
    sendSearchRequestSpy = jest.spyOn(sendSearchRequestInterface, "sendSearchRequest");
    streamQuerySpy = jest.spyOn(streamQueryInterface, "streamQueryV2");
  });

  afterEach(() => {
    jest.resetAllMocks();
  });

  describe("streaming", () => {
    it("should send messages and update hook values", async () => {
      const { result } = renderHook(() =>
        useChat({ customerId: "mock-customer-id", corpusKeys: "1", apiKey: "mock-api-key" })
      );

      streamQuerySpy.mockImplementation(async ({ onStreamEvent }) => {
        await onStreamEvent({
          type: "generationChunk",
          updatedText: "mock-updated-text"
        });
      });

      await act(async () => {
        await result.current.sendMessage({ query: "mock-query" });
      });

      expect(result.current.activeMessage).toEqual({
        type: "turn",
        answer: "mock-updated-text",
        id: "placeholder-message-id",
        question: "mock-query",
        results: []
      });

      expect(result.current.isStreamingResponse).toEqual(true);
      expect(result.current.messageHistory).toEqual([]);

      streamQuerySpy.mockImplementation(async ({ onStreamEvent }) => {
        await onStreamEvent({
          type: "end"
        });
      });

      await act(async () => {
        await result.current.sendMessage({ query: "mock-query" });
      });

      await waitFor(() => {
        expect(result.current.messageHistory.length).toEqual(1);
      });
    });
  });

  describe("non-streaming", () => {
    it("should send messages and update message history", async () => {
      const { result } = renderHook(() =>
        useChat({ customerId: "mock-customer-id", corpusKeys: "1", apiKey: "mock-api-key", enableStreaming: false })
      );

      sendSearchRequestSpy.mockImplementation(() => Promise.resolve(MOCK_API_RESPONSE));

      await act(async () => {
        await result.current.sendMessage({ query: "mock-query" });
      });

      expect(sendSearchRequestSpy).toHaveBeenCalledWith(
        expect.objectContaining({
          query: "mock-query"
        })
      );

      expect(result.current.messageHistory.length).toEqual(1);
    });

    it("should reflect error state", async () => {
      const { result } = renderHook(() =>
        useChat({ customerId: "mock-customer-id", corpusKeys: "1", apiKey: "mock-api-key", enableStreaming: false })
      );
      sendSearchRequestSpy.mockImplementation(() => {
        throw "error";
      });

      await act(async () => {
        result.current.sendMessage({ query: "mock-query" });
      });

      expect(result.current.hasError).toEqual(true);
    });

    it("should reflect loading state", async () => {
      const { result } = renderHook(() =>
        useChat({ customerId: "mock-customer-id", corpusKeys: "1", apiKey: "mock-api-key" })
      );
      sendSearchRequestSpy.mockImplementation(() => {
        return new Promise(() => {});
      });

      act(() => {
        result.current.sendMessage({ query: "mock-query" });
      });

      expect(result.current.isLoading).toEqual(true);
    });
  });

  describe("agentic behavior", () => {
    (globalThis as any).fetch ||= jest.fn();
    const global = globalThis as typeof globalThis & { fetch: any };

    it("should be able to respond with pre-configured messages from agentic service responses", async () => {
      const mockFetch = jest.spyOn(global, "fetch").mockResolvedValue({
        status: 200,
        json: jest.fn().mockResolvedValue({ event: "mock-event" })
      });

      const { result } = renderHook(() =>
        useChat({
          customerId: "mock-customer-id",
          corpusKeys: "1",
          apiKey: "mock-api-key",
          enableStreaming: true,
          agenticConfiguration: {
            url: "path/to/agentic-service",
            onAgenticResponse: (response: AgenticResponse) => {
              if (response.event === "mock-event") {
                return {
                  message: AGENTIC_RESPONSE_MESSAGE_WITH_CONTENT_OVERRIDE
                };
              }
            }
          }
        })
      );

      await act(async () => {
        await result.current.sendMessage({ query: "Can I speak with sales?" });
      });

      await act(async () => {
        // There should only be one item in message history, containing:
        //   - the message from the user
        //   - the answer to the user's message, provided via onAgenticResponse return value
        expect(result.current.messageHistory.length === 1);
        expect((result.current.messageHistory[0] as ChatTurn).answer).toEqual(
          AGENTIC_RESPONSE_MESSAGE_WITH_CONTENT_OVERRIDE.content
        );
      });

      mockFetch.mockRestore();
    });

    it("should be able to append messages from agentic service responses to the generated response from the query API", async () => {
      const mockFetch = jest.spyOn(global, "fetch").mockResolvedValue({
        status: 200,
        json: jest.fn().mockResolvedValue({ event: "mock-event" })
      });

      const { result } = renderHook(() =>
        useChat({
          customerId: "mock-customer-id",
          corpusKeys: "1",
          apiKey: "mock-api-key",
          enableStreaming: true,
          agenticConfiguration: {
            url: "path/to/agentic-service",
            onAgenticResponse: (response: AgenticResponse) => {
              if (response.event === "mock-event") {
                return {
                  message: AGENTIC_RESPONSE_MESSAGE_TO_APPEND_TO_QUERY_REPONSE
                };
              }
            }
          }
        })
      );

      streamQuerySpy.mockImplementation(async ({ onStreamEvent }) => {
        await onStreamEvent({
          type: "generationChunk",
          updatedText: "mock-updated-text"
        });
        await onStreamEvent({
          type: "end"
        });
      });

      await act(async () => {
        await result.current.sendMessage({ query: "mock-query" });
      });

      await act(async () => {
        // There should only be one item in message history, containing:
        //   - the message from the user
        //   - the answer to the user's message, provided via onAgenticResponse return value
        expect(result.current.messageHistory.length === 1);
        expect((result.current.messageHistory[0] as ChatTurn).answer).toEqual(
          `mock-updated-text<br><br>${AGENTIC_RESPONSE_MESSAGE_TO_APPEND_TO_QUERY_REPONSE.post}`
        );
      });

      mockFetch.mockRestore();
    });

    it("should be able to show available user actions based on agentic service responses", async () => {
      const mockFetch = jest.spyOn(global, "fetch").mockResolvedValue({
        status: 200,
        json: jest.fn().mockResolvedValue({ event: "mock-event" })
      });

      const userActionOptions = [
        {
          label: "Action 1",
          message: "Message to chatbot after selecting Action 1"
        },
        {
          label: "Action 2",
          message: "Message to chatbot after selecting Action 2"
        }
      ];

      const { result } = renderHook(() =>
        useChat({
          customerId: "mock-customer-id",
          corpusKeys: "1",
          apiKey: "mock-api-key",
          enableStreaming: false,
          agenticConfiguration: {
            url: "path/to/agentic-service",
            onAgenticResponse: (response: AgenticResponse) => {
              if (response.event === "mock-event") {
                return {
                  message: AGENTIC_RESPONSE_MESSAGE_WITH_CONTENT_OVERRIDE,
                  userActionOptions
                };
              }
            }
          }
        })
      );

      await act(async () => {
        await result.current.sendMessage({ query: "Can I speak with sales?" });
      });

      await act(async () => {
        jest.advanceTimersByTime(1000);

        // There should only be two items in message history
        //   - item 1 (a "turn" object), containing:
        //     - the message from the user
        //     - the answer to the user's message, provided via onAgenticResponse return value
        //   - item 2 (an "action" object), containing:
        //     - an array of configurations representing actions a user can take to respond
        expect(result.current.messageHistory.length === 2);
        expect(result.current.messageHistory[0]).toEqual(
          expect.objectContaining({
            type: "turn",
            answer: AGENTIC_RESPONSE_MESSAGE_WITH_CONTENT_OVERRIDE.content
          })
        );
        expect(result.current.messageHistory[1]).toEqual(
          expect.objectContaining({
            type: "action",
            options: userActionOptions
          })
        );
      });

      mockFetch.mockRestore();
    });
  });

  it("should be able to reset the conversation", async () => {
    const { result } = renderHook(() =>
      useChat({ customerId: "mock-customer-id", corpusKeys: "1", apiKey: "mock-api-key", enableStreaming: false })
    );
    sendSearchRequestSpy.mockImplementation(() => Promise.resolve(MOCK_API_RESPONSE));

    await act(async () => {
      await result.current.sendMessage({ query: "mock-query" });
      await result.current.sendMessage({ query: "mock-query-2" });
    });

    // Assert that the second request uses the current conversation id.
    expect(sendSearchRequestSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        chat: { store: true, conversationId: "mock-conversation-id" }
      })
    );

    sendSearchRequestSpy.mockImplementation(() =>
      Promise.resolve({
        ...MOCK_API_RESPONSE,
        chat_id: "mock-conversation-id-2",
        turn_id: "mock-turn-id",
        answer: "mock-answer"
      })
    );

    await act(async () => {
      await result.current.startNewConversation();
    });

    expect(result.current.messageHistory.length).toEqual(0);

    await act(async () => {
      await result.current.sendMessage({ query: "mock-query-3" });
    });

    const calls = sendSearchRequestSpy.mock.calls;
    const recentSendSearchRequestCall = calls[calls.length - 1][0];

    // Assert that the request after reset is has no conversation id.
    expect(recentSendSearchRequestCall.chat.conversationId).toEqual(undefined);
  });
});
